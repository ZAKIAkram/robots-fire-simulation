\documentclass[french, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{lastpage}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{pgfplots}
\usepackage{float}
\usepackage{pdfpages}

\usepackage{pgfplots}

\usepackage[a4paper, left=1.8cm, right=1.8cm, top=2.5cm, bottom=3.2cm]{geometry}

\def\UrlBreaks{\do\/\do-\do_}



\pagestyle{fancy}
\fancyhf{}
\setlength{\headsep}{1.2cm}
\lhead{
	\includegraphics[scale=0.35]{../rapport/ressources/logo_ensimag.jpg}
}
\chead{JAVA -2A\\}
\rhead{Projet Java \\ Année universitaire 2022 - 2023}
\lfoot{Ensimag - Année 2 - S7\\\small{Equipe: 43}}
\rfoot{\thepage/\pageref{LastMainPage}\\\today}

\renewcommand*\contentsname{Table des matières}

\makeatletter
\newcommand*{\centerfloat}{%
	\parindent \z@
	\leftskip \z@ \@plus 1fil \@minus \textwidth
	\rightskip\leftskip
	\parfillskip \z@skip}
\makeatother



\begin{document}
		
	\setcounter{page}{1}
	\begin{center}
		\section*{Rapport projet tpl}
	\end{center}
	

 \textbf{Pour les informations de compilation veuillez lire README.txt dans le repertoire du rendu. }

\section*{Gestion des évenements:}
	A la question de la gestion des évenements, on a décidé d'utiliser \textit{SortedMap\textless{}Long, LinkedList\textless{}Evenement\textgreater{}\textgreater{}} pour stocker tous les événements générer au cours de l'exécution. Donc en cliquant sur Next ou sur lecture (qui fait des nexts successives tous une liste des événements de même date K sera exécuté, et si la liste est vide on fera aucune mise à jour et d'ailleurs c'est la manière qui permet se représente le temps d'attente. \\

	Les mécanismes de la gestion du temps consistent la partie la plus importante de notre conception, vu qu'on a essayé de conserver les données différentes de chaque robot (temps d'extinction, temps de déplacement en fonction de la vitesse, temps de la charge du réservoir). Les décalages entre le temps de charge, extinction et déplacement étaient énormes c'est la raison pour laquelle on a décidé de créer une échelle pour chaque événement tout en conservant le décalage visuel (le nombre d'incrémentation de la date courante est énorme, c'est tout à fait logique vu que par exemple drone remplit son réservoir en $30 min = 60\times{30} = 3600s$) Donc on calcule un temps d'attente pour chaque événement qui sera converti en une date qui representra une clé dans la structure des évenements qui representra une clé dans la structure des événements.\\


	Notre idée de la conception peut paraître perturbante, mais elle devient très intuitive si on imagine deux fils des actions : le prince de décision et l'exécution réelle. Les variables courantes (reservoir Courant, intensitecourante, position Courante) changent à chaque insertion des événements au moment de la prise de décision et les autres (réservoir, intensité, position) changent pendant leurs dates effectives dans la liste des événements.\\

	Au moment du démarrage du programme, et après l'affectation des incendies on est toujours dans la date de simulation 1, or il faut ajouter les déplacements élémentaires de la position actuelle du robot vers la position destinataire. Si un déplacement élémentaire coutera 4 dates par exemple donc la position réelle du robot (referée dans le code par position) ne changera qu'à la date courante de l'exécution 4. Enfin, si on veut ajouter d'autres événements avant la date 4 toujours pendant la date courante 1 on n'utilisera la position virtuelle du robot référée dans le code par position Courante . Le fil de la prise de décision est toujours en avance du fil de l'exécution car il nous permet d'insérer plusieurs événements à la fois ( déplacement + éteindre incendie et l'aller-retour pour remplir le réservoir) dans une même date courante.\\

	L'attribut clé dans cette conception est datearrivee dans la classe robot. Il sert à détecter la date dans la liste des événements à partir de laquelle le robot est libre. C'est une date qui change au cours de chaque prise de décision d'un événement en fonction du temps d'attente calculé.\\
	
\includegraphics[scale=0.6]{../rapport/ressources/r.jpeg}
	
\section*{Plus court chemin:}	
	Il y’a plusieurs algorithmes, Breadth First Algorithm BFS, Dijkstra's Algorithm et A* Algorithm. L’idée générale de ces algorithmes est que nous gardons une idée sur la frontière en expansion. L’algorithme BFS explore toutes les directions, L’algorithme de Dijkstra permet de donner une certaine priorité à des pistes. Au lieu d’explorer toutes les voies possibles de la même manière, il privilégie les chemins à moindre coût mais, il fait perdre du temps en explorant des directions qui ne
donnent pas le plus court chemin. l’algorithme A* est une version optimisée de l’algorithme de Dijkstra. A* trouve des chemins vers un emplacement, ou le plus proche de plusieurs. Et bien sûr donne la priorité aux chemins qui semblent se rapprocher de la destination. \\

\textbf{Algorithme choisi : A*} \\
	Mais pour que l’algorithme A* soit le plus optimal possible, il lui faut une fonction de coût bien
choisie, qu’on appelle f, On a $f = g + h$.
$g$ : $g(current)$ c’est le nombre de pas fait pour aller de la case source vers la case current.
$h$ : $h(current)$ c’est le coût heuristique estimé de current vers la destination.
Donc pour bien choisir $f$, il faut bien choisir $h$, (car $g$ reste la même). \\

\textbf{Choix de la fonction heuristique $h$:} \\
	Vu que les robots n’ont qu’un mouvement dans 4 directions, on ne peut pas utiliser la distance euclidienne. donc la distance la plus adaptée aux cartes de 4 directions est la distance de Manhattan. c’est la somme de deux différences des abscisses et des ordonnées de la case et la destination en valeur absolue.
$$|(source.x - destination.x)| + |(source.y - destination.y)|$$
Il faut aussi prendre en compte le temps nécessaire pour arriver à la destination. du coup la fonction heuristique qu’on va utiliser est de la forme :
$$h(case) = manhattanDistance(case, destination)\times{\frac{(tailleCase)}{vitesse}}$$ \\
vitesse : vitesse du robot dans cette case. \\
tailleCase : taille de la case en mètre. \\

	Mais, il faut privilégier les chemins qui sont (quasiment) sur la ligne droite de la case source à la destination. Pour ce faire, on calcule le produit vectoriel entre le vecteur (source $ \rightarrow$ destination) et (case Courante $ \rightarrow$ destination). Lorsque ces vecteurs ne sont pas (quasiment) colinéaires, ce produit vectoriel sera plus grand. donc on va privilégier les chemins qui sont sur la ligne du premier vecteur (source $ \rightarrow$ destination) en augmentant(légèrement) les coûts des autres chemins. Et cela aide l’algotithme A* à explorer moins de chemins.
	
Donc la fonction heuristique finale est :
 $$\boxed{h(case) = manhattanDistance(case, destination) *( (tailleCase) / vitesse) + produitVectoriel * 0.001}$$ \\
 produitVectoriel = (source $ \rightarrow$ destination) $\wedge$ (case Courante $ \rightarrow$ destination) \\
 
 \textbf{NB :} on utilise pas A* pour les drones, car il n’y a pas d’obstacles pour eux. on utilise un algorithme très simple. On essaye d’augmenter (ou diminuer) les abscisses (colonnes) et les ordonnées (ligne) de la position du drone jusqu’à l’arrivée du drone vers la destination.

	\label{LastMainPage}
		
\end{document}
	
